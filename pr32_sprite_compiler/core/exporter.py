from pathlib import Path
from typing import List, Tuple, Dict
from PIL import Image
from pr32_sprite_compiler.core.models import SpriteDefinition, CompilationOptions
from pr32_sprite_compiler.core.compiler import SpriteCompiler

class Exporter:
    # Predefined palettes from PaletteDefs.h
    PREDEFINED_PALETTES = {
        "PALETTE_NES": [
            (0, 0, 0), (255, 241, 232), (29, 43, 83), (41, 173, 255),
            (255, 204, 170), (0, 135, 81), (0, 228, 54), (255, 236, 39),
            (255, 163, 0), (171, 82, 54), (255, 119, 168), (255, 0, 77),
            (126, 37, 83), (131, 118, 156), (95, 87, 79), (194, 195, 199)
        ],
        "PALETTE_GB": [
            (15, 56, 15), (244, 255, 235), (62, 95, 42), (92, 127, 58),
            (175, 207, 143), (27, 77, 27), (48, 98, 48), (79, 127, 63),
            (155, 188, 15), (182, 201, 106), (221, 239, 199), (139, 172, 15),
            (107, 143, 78), (127, 174, 92), (232, 247, 220), (207, 229, 165)
        ],
        "PALETTE_GBC": [
            (0, 0, 0), (248, 248, 248), (24, 24, 120), (32, 56, 236),
            (88, 168, 248), (8, 24, 32), (52, 104, 86), (136, 192, 112),
            (248, 224, 48), (216, 144, 0), (248, 184, 184), (176, 48, 48),
            (232, 80, 80), (123, 104, 238), (224, 248, 208), (160, 160, 160)
        ],
        "PALETTE_PICO8": [
            (0, 0, 0), (255, 241, 232), (29, 43, 83), (41, 173, 255),
            (255, 204, 170), (0, 135, 81), (0, 228, 54), (255, 236, 39),
            (255, 163, 0), (171, 82, 54), (255, 119, 168), (255, 0, 77),
            (126, 37, 83), (131, 118, 156), (95, 87, 79), (194, 195, 199)
        ],
        "PALETTE_PR32": [
            (0, 0, 0), (255, 255, 255), (27, 31, 59), (0, 71, 255),
            (0, 194, 255), (14, 122, 13), (46, 204, 64), (168, 255, 158),
            (255, 213, 0), (255, 159, 28), (199, 125, 255), (193, 18, 31),
            (106, 4, 15), (123, 44, 191), (206, 206, 206), (141, 141, 141)
        ]
    }

    @staticmethod
    def _get_palette_match(colors: List[Tuple[int, int, int]]) -> str:
        """Checks if the given colors match any predefined palette."""
        colors_set = set(colors)
        for name, palette in Exporter.PREDEFINED_PALETTES.items():
            palette_set = set(palette)
            if colors_set.issubset(palette_set):
                return name
        return None

    @staticmethod
    def export(img: Image.Image, sprites: List[SpriteDefinition], options: CompilationOptions):
        compiler = SpriteCompiler()
        colors = compiler.extract_colors(img)
        
        palette_match = Exporter._get_palette_match(colors)
        
        palette_map = {}
        if options.mode in ["2bpp", "4bpp"]:
            max_colors = 3 if options.mode == "2bpp" else 15
            
            if palette_match:
                # Use predefined palette mapping
                palette = Exporter.PREDEFINED_PALETTES[palette_match]
                for i, color in enumerate(palette):
                    if color in colors:
                        palette_map[color] = i
            else:
                # Custom palette mapping
                for i, color in enumerate(colors):
                    if i < max_colors:
                        palette_map[color] = i + 1
                    else:
                        palette_map[color] = max_colors

        out_path = Path(options.output_path)
        prefix = f"{options.name_prefix}_" if options.name_prefix else ""
        
        with open(out_path, "w", encoding="utf-8", newline="\n") as f:
            f.write("// Generated by PixelRoot32 Sprite Compiler\n")
            f.write("// Engine: PixelRoot32\n")
            f.write(f"// Mode: {options.mode}\n\n")

            if options.mode in ["2bpp", "4bpp"]:
                if palette_match:
                    f.write(f"// Using predefined palette: {palette_match}\n\n")
                else:
                    f.write(f"// Palette ({len(palette_map)} colors + transparent):\n")
                    f.write("// Index 0: Transparent\n")
                    processed_indices = set()
                    for i in range(1, max(palette_map.values()) + 1 if palette_map else 1):
                        for c, idx in palette_map.items():
                            if idx == i and i not in processed_indices:
                                r, g, b = c
                                f.write(f"// Index {i}: RGB({r}, {g}, {b})\n")
                                processed_indices.add(i)
                                break
                    f.write("\n")
                    
                    f.write("using pixelroot32::graphics::Color;\n\n")
                    f.write("// Palette mapping for the sprite (1:1 mapping to global palette indices)\n")
                    f.write(f"static const Color {prefix}PALETTE_MAPPING[16] = {{\n")
                    # Generate mapping
                    mapping = ["(Color)0"] * 16
                    for c, idx in palette_map.items():
                        if idx < 16:
                            mapping[idx] = f"(Color){idx}"
                    
                    for i in range(0, 16, 4):
                        f.write(f"    {', '.join(mapping[i:i+4])},\n")
                    f.write("};\n\n")

            for s_def in sprites:
                x = options.offset_x + s_def.gx * options.grid_w
                y = options.offset_y + s_def.gy * options.grid_h
                w = s_def.gw * options.grid_w
                h = s_def.gh * options.grid_h

                cropped = img.crop((x, y, x + w, y + h))
                sprite = Image.new("RGBA", (w, h), (0, 0, 0, 0))
                sprite.paste(cropped, (0, 0))
                
                f.write(f"// Sprite {s_def.index} Dimensions: {w}x{h}\n")

                if options.mode == "layered":
                    for layer, color in enumerate(colors):
                        bits = compiler.sprite_to_bits(sprite, color)
                        name = f"{prefix}SPRITE_{s_def.index}_LAYER_{layer}"
                        f.write(f"static const uint16_t {name}[] = {{\n")
                        for row in bits:
                            for word in row:
                                f.write(f"    0x{word:04X},\n")
                        f.write("};\n\n")
                
                elif options.mode == "2bpp":
                    bits = compiler.pack_2bpp(sprite, palette_map)
                    name = f"{prefix}SPRITE_{s_def.index}_2BPP"
                    f.write(f"static const uint16_t {name}[] = {{\n")
                    for row in bits:
                        for word in row:
                            f.write(f"    0x{word:04X},\n")
                    f.write("};\n\n")

                elif options.mode == "4bpp":
                    bits = compiler.pack_4bpp(sprite, palette_map)
                    name = f"{prefix}SPRITE_{s_def.index}_4BPP"
                    f.write(f"static const uint16_t {name}[] = {{\n")
                    for row in bits:
                        for word in row:
                            f.write(f"    0x{word:04X},\n")
                    f.write("};\n\n")
        return True
