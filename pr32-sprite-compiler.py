#!/usr/bin/env python3
from PIL import Image
import argparse
from pathlib import Path
import sys

def parse_grid(value):
    w, h = value.lower().split("x")
    return int(w), int(h)

def parse_sprite(value):
    gx, gy, gw, gh = value.split(",")
    return int(gx), int(gy), int(gw), int(gh)

def extract_colors(img):
    pixels = img.load()
    colors = set()
    for y in range(img.height):
        for x in range(img.width):
            r, g, b, a = pixels[x, y]
            if a > 0:
                colors.add((r, g, b))
    return sorted(colors)

def sprite_to_bits(sprite, color):
    pixels = sprite.load()
    rows = []

    words_per_row = (sprite.width + 15) // 16

    for y in range(sprite.height):
        row_words = [0] * words_per_row

        for x in range(sprite.width):
            r, g, b, a = pixels[x, y]
            if a > 0 and (r, g, b) == color:
                word = x // 16
                bit = 15 - (x % 16)
                row_words[word] |= (1 << bit)

        rows.append(row_words)

    return rows

def main():
    parser = argparse.ArgumentParser(
        description="PixelRoot32 sprite sheet compiler"
    )
    parser.add_argument("input", help="Input PNG sprite sheet")
    parser.add_argument("--grid", required=True, help="Grid size WxH (e.g. 16x16)")
    parser.add_argument(
        "--offset",
        default="0,0",
        help="Grid offset X,Y (default: 0,0)",
    )
    parser.add_argument(
        "--sprite",
        action="append",
        required=True,
        help="Sprite definition gx,gy,gw,gh (grid units)",
    )
    parser.add_argument(
        "--out",
        default="sprites.h",
        help="Output header file (default: sprites.h)",
    )

    args = parser.parse_args()

    input_path = Path(args.input)
    if not input_path.exists():
        print(f"ERROR: input file not found: {input_path}")
        sys.exit(1)

    img = Image.open(input_path).convert("RGBA")
    
    if args.grid:
        grid_w, grid_h = parse_grid(args.grid)
    else:
        # Auto-detect grid logic (ported from GUI)
        width, height = img.size
        
        def divisors(n: int):
            result = set()
            limit = int(n**0.5) + 1
            for d in range(1, limit):
                if n % d == 0:
                    result.add(d)
                    result.add(n // d)
            return sorted(result)

        candidates = [d for d in divisors(width) if 8 <= d <= width]
        preferred = [16, 32, 8, 24, 48, 64]
        
        grid_w = None
        for p in preferred:
            if p in candidates:
                grid_w = p
                break
        
        if grid_w is None:
            if candidates:
                grid_w = max(candidates)
            else:
                grid_w = width
        
        grid_h = grid_w # Assume square grid cells for auto-detect
        print(f"INFO: Auto-detected grid size: {grid_w}x{grid_h}")

    offset_x, offset_y = 0, 0
    if args.offset:
        ox, oy = args.offset.split(",")
        offset_x, offset_y = int(ox), int(oy)

    if args.sprite:
        sprites = [parse_sprite(s) for s in args.sprite]
    else:
        # Auto-generate sprites filling the grid (ported from GUI)
        cols = max(1, img.width // grid_w)
        rows = max(1, img.height // grid_h)
        sprites = []
        for gy in range(rows):
            for gx in range(cols):
                sprites.append((gx, gy, 1, 1))
        print(f"INFO: Auto-generated {len(sprites)} sprites ({cols} cols x {rows} rows).")

    colors = extract_colors(img)

    if len(colors) > 4:
        print(f"WARNING: Detected {len(colors)} colors (layers).")
        print("         Performance may degrade on ESP32 if using > 4 layers for main characters.")
        print("         Consider using 4bpp packed sprites for higher color counts.")

    out_path = Path(args.out)

    with open(out_path, "w", encoding="utf-8", newline="\n") as f:
        f.write("// Generated by pr32-sprite-compiler\n")
        f.write("// Engine: PixelRoot32\n\n")

        for idx, (gx, gy, gw, gh) in enumerate(sprites):

            x = offset_x + gx * grid_w
            y = offset_y + gy * grid_h
            w = gw * grid_w
            h = gh * grid_h

            # Crop and pad if necessary
            cropped = img.crop((x, y, x + w, y + h))
            sprite = Image.new("RGBA", (w, h), (0, 0, 0, 0))
            sprite.paste(cropped, (0, 0))

            for layer, color in enumerate(colors):
                bits = sprite_to_bits(sprite, color)
                name = f"SPRITE_{idx}_LAYER_{layer}"

                f.write(f"static const uint16_t {name}[] = {{\n")
                for row in bits:
                    for word in row:
                        f.write(f"    0x{word:04X},\n")
                f.write("};\n\n")

    print(f"OK: generated {out_path}")

if __name__ == "__main__":
    main()
