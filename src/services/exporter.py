from pathlib import Path
from typing import List, Tuple, Dict
from PIL import Image
from src.core.models import SpriteDefinition, CompilationOptions
from src.core.compiler import SpriteCompiler

class Exporter:
    @staticmethod
    def export(img: Image.Image, sprites: List[SpriteDefinition], options: CompilationOptions):
        compiler = SpriteCompiler()
        colors = compiler.extract_colors(img)
        
        palette_map = {}
        if options.mode in ["2bpp", "4bpp"]:
            max_colors = 3 if options.mode == "2bpp" else 15
            for i, color in enumerate(colors):
                if i < max_colors:
                    palette_map[color] = i + 1
                else:
                    palette_map[color] = max_colors

        out_path = Path(options.output_path)
        with open(out_path, "w", encoding="utf-8", newline="\n") as f:
            f.write("// Generated by PixelRoot32 Sprite Compiler\n")
            f.write("// Engine: PixelRoot32\n")
            f.write(f"// Mode: {options.mode}\n\n")

            if options.mode in ["2bpp", "4bpp"]:
                f.write(f"// Palette ({len(palette_map)} colors + transparent):\n")
                f.write("// Index 0: Transparent\n")
                processed_indices = set()
                for i in range(1, max(palette_map.values()) + 1 if palette_map else 1):
                    for c, idx in palette_map.items():
                        if idx == i and i not in processed_indices:
                            r, g, b = c
                            f.write(f"// Index {i}: RGB({r}, {g}, {b})\n")
                            processed_indices.add(i)
                            break
                f.write("\n")

            for s_def in sprites:
                x = options.offset_x + s_def.gx * options.grid_w
                y = options.offset_y + s_def.gy * options.grid_h
                w = s_def.gw * options.grid_w
                h = s_def.gh * options.grid_h

                cropped = img.crop((x, y, x + w, y + h))
                sprite = Image.new("RGBA", (w, h), (0, 0, 0, 0))
                sprite.paste(cropped, (0, 0))
                
                f.write(f"// Sprite {s_def.index} Dimensions: {w}x{h}\n")

                if options.mode == "layered":
                    for layer, color in enumerate(colors):
                        bits = compiler.sprite_to_bits(sprite, color)
                        name = f"SPRITE_{s_def.index}_LAYER_{layer}"
                        f.write(f"static const uint16_t {name}[] = {{\n")
                        for row in bits:
                            for word in row:
                                f.write(f"    0x{word:04X},\n")
                        f.write("};\n\n")
                
                elif options.mode == "2bpp":
                    bits = compiler.pack_2bpp(sprite, palette_map)
                    name = f"SPRITE_{s_def.index}_2BPP"
                    f.write(f"static const uint16_t {name}[] = {{\n")
                    for row in bits:
                        for word in row:
                            f.write(f"    0x{word:04X},\n")
                    f.write("};\n\n")

                elif options.mode == "4bpp":
                    bits = compiler.pack_4bpp(sprite, palette_map)
                    name = f"SPRITE_{s_def.index}_4BPP"
                    f.write(f"static const uint16_t {name}[] = {{\n")
                    for row in bits:
                        for word in row:
                            f.write(f"    0x{word:04X},\n")
                    f.write("};\n\n")
        return True
